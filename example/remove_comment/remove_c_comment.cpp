/******************************************************** 
    功能：去除C/C++中的註釋 
    輸入：指向C/C++程序代碼的指針 
    來源：程序員面試寶典第45頁 
    注意：①要考慮到""或' '中的//和/*，//和/*的嵌套關係。 
          ②單引號、雙引號中的//是兩個字符，第一個字符在單引號的case語句中跳過了， 
          第二個字符則在case '/'中處理。 
 *********************************************************/  
  
#include <stdio.h>  
#include <stdlib.h>  
#include <fcntl.h>  
#include <string.h>  
#include <unistd.h>  
#include <sys/types.h>  
  
void remove_comment(char *buf, size_t size)  
{  
    char *p, *end, c;          //p-動態移動的字符指針，end-指向文件末尾的字符指針，c-存儲沒一個p指向的字符  
    char *sq_start, *dq_start; //sq_start-單引號開始位置（single），dq_start-雙引號開始（double）  
    char *lc_start, *bc_start; //lc_start-//的開始位置，bc_start-/*的開始位置  
    size_t len;                //記錄某符號結束和開始的位置之差（長度，偏移量）  
      
    p = buf;  
    end = p + size;  
    sq_start = dq_start = NULL;  
    lc_start = bc_start = NULL;  
      
    while (p < end) /*當指針沒有到達文件末尾   \r///***///*/,故意帶這些不規範的符號的，因為調試就用這個代碼，哈哈。*/  
    {  
        c = *p;     //用字符變量c存儲指針指向的字符  
          
        switch (c) //根據c的值做相應處理  
        {  
            case '\'': /*處理單引號，其實只是為了排除'//'的情況，否則不需要有這個情況判斷*/  
            {  
                if (dq_start || lc_start || bc_start) //當遇到過雙引號、//或/*的時候，則不需要再判斷'//'的情況了。  
                {  
                    p++;  
                    continue; //繼續下一個，對while而言的  
                }  
                /*******************************以下是沒有遇到過雙引號或//或/*的時候*******************************/  
                if (sq_start == NULL) /****否則：如果未遇到單引號****/  
                {  
                    sq_start = p++; //start指向單引號的開始位置，p指向下一個（分兩句理解）  
                }  
                else /*如果遇到過單引號，sq_start指向單引號開始位置*/  
                {  
                    len = (p++) -sq_start; //len = p-sq_start; p++;  
                    if (len == 2 && *(sq_start+1) == '\\') //這個是將遇到'//'的情況排除  
                    {  
                        continue; //忽略單引號中單獨存在//的時候，即不再往下處理。  
                    }  
                      
                    sq_start = NULL; //否則將sq_start置位為NULL，C語言中單引號內最多只可能有一個字符而已，不要思考複雜了哦len == 0 或 1 或 2  
                }  
                /*******************************以上是沒有遇到過雙引號或//或/*的時候*******************************/  
                break;  
            }  
              
            case '\"': /*處理雙引號，其實只也是為了排除"//"的情況，否則不需要有這個情況判斷，注意第二個斜槓不在這裡判斷*/  
            {  
                if (sq_start || lc_start || bc_start) //當遇到過單引號、//或/*的時候，則不需要處理  
                {  
                    p++;  
                    continue;  
                }  
                /*****************以下是沒有遇到過單引號或//或/*的時候*****************/  
                if (dq_start == NULL) /*如果沒有遇到過雙引號*/  
                {  
                    dq_start = p++; //標記遇到了雙引號  
                }  
                else if (*((p++) -1) =='\\') //雙引號中的/也不需要處理。  
                {  
                    continue;  
                }  
                printf("hello // world?? /**/"); //這種情況呢？怎麼辦？——這個情況會在遇到/是的第一個if語句被跳過  
                  
                  
                dq_start = NULL; //如果雙引號中不是//，標記為NULL  
                /*****************以上是沒有遇到過單引號或//或/*的時候*****************/  
            }  
              
            case '/': //斜槓，注意這個斜槓也可以是'//'，"//",//,/*/中的第二個斜槓，但會在下面第二行代碼中被忽略掉  
            {  
                if (sq_start || dq_start || lc_start || bc_start) //如果是單引號、雙引號、斜槓、/*的後面  
                {  
                    p++;  
                    continue;  
                }  
                /***********************下面是遇到註釋//或/*的時候****************************/  
                c = *(p + 1); //否則c取p指向字符的下一個字符  
                if (c == '/') //遇到了雙斜槓  
                {  
                    lc_start = p; //標記雙斜槓的開始  
                    p += 2; //p指向雙斜槓後面的字符  
                }  
                else if (c == '*') //遇到了/*  
                {  
                    bc_start = p; //標記/*的開始  
                    p += 2; //p指向/*後面的字符  
                }  
                /*************************上面是遇到註釋//或/*的時候**************************/  
                else  
                { //其它情況，再去判斷下一個是什麼符號——注意：C程序可以有其他情況嗎？這句話我認為永遠不可能執行到。  
                    p++;   
                }  
            }  
              
            case '*': //星號，同斜槓，但少了如果遇到/*的情況，因為遇到這種情況後，要判斷是不是遇到結束的地方*/了  
            {  
                if (sq_start || dq_start || lc_start) //如果是單引號、雙引號、斜槓、/*的後面  
                {  
                    p++;  
                    continue;   
                }  
                  
                if (*(p + 1) != '/') //如果星號後面緊跟的不是斜槓，那麼忽略過。  
                {  
                    p++;  
                    continue;  
                }  
                  
                p += 2; //否則p指向斜槓後面那個字符。注意下面的清空語句，p指向的那個字符並不會被清除。  
                memset(bc_start, ' ', p-bc_start); //清空/* …… */中間的內容包括註釋符號本身。  
                bc_start = NULL;  
                break;  
            }  
              
            case '\n': /*換行符，主要處理遇到雙斜槓時，需要清除雙斜槓到\n的前面的字符*/  
            {  
                if (lc_start == NULL) //如果還沒有遇到雙斜槓，那麼忽略  
                {  
                    p++;  
                    continue; /*這兩行本程序每次case後面都緊跟，就是忽略過的意思*/  
                }  
                  
                c = *(p - 1);  
                //如果遇到過雙斜槓，清空雙斜槓本身和到n前面的那個字符，p指向下一個字符，/r是回車符（光標退回到最前面），要忽略。有這個情況嗎？？？  
                memset(lc_start, ' ', (c == '\r'? ((p++) -1) : p++) - lc_start);   
                lc_start = NULL;  
                break;  
            }  
              
            default:  
                p++;  
                break;  
        }  
        /**************************************************** 
        如果遇到雙斜槓，這個if語句存在的意義在於萬一最後 
        一行代碼是帶有雙斜槓但沒有給換行符\n的，也要清除掉。 
        不帶文件末尾的雙斜槓的行尾一定有\n，這不是代碼中寫的 
        \n而是我們的回車鍵換行操作寫入文件的。 
        *****************************************************/  
        if (lc_start)   
        {  
            memset(lc_start, ' ', p - lc_start);  
        }  
    }  
}  
  
/********************************************** 
            main函數的開始 
***********************************************/  
int main (int argc, char *argv[])  
{  
    int fd, n;  
    char buf[102400];  
      
    if (argc != 2)  
    {  
        printf("command error: Input as ./command <file>\n");  
    }  
      
    fd = open(argv[1], O_RDONLY); /*只讀打開*/  
    if (fd == -1)  
    {  
        return -1;  
    }  
      
    n = read(fd, buf, sizeof(buf));  
    if (n == -1 || n == 0)  
    {  
        close(fd);  
        return -1;  
    }  
    printf("test\n");  
    remove_comment(buf, n);  
    *(buf + n) = '\0';  
    printf("%s", buf);  
    close(fd);  
      
    return 0;  
}  